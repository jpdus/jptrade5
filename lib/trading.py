__author__ = 'jph'

import datetime as dt
import random
import threading
import time
from Queue import Queue

import pytz

from lib.events import FillEvent, ErrorEvent, StartStopEvent


class TradingHandler(object):
    """
    Handles interface between orders, generated by a portfolio and fills
    uses connection to brokerage
    """

    def __init__(self, queue):
        self.queue = queue
        self.est = pytz.timezone('US/Eastern')
        self.cet = pytz.timezone('Europe/Berlin')

    def execute_order(self, event):
        """
        executes order
        """
        raise NotImplementedError


class FakeInstantTradingHandler(TradingHandler):
    """
    simulates instant fills
    """

    def __init__(self, queue):
        super(FakeInstantTradingHandler, self).__init__(queue)
        self.fakeid = 37

    def execute_order(self, event):
        price = 190 + round(random.random() * 10, 2)
        fill_event = FillEvent(event.symbol,
                               'BATS', event.quantity, event.side, 2, self.fakeid, price, ordereventid=event.id)
        self.fakeid += 1
        self.queue.put(fill_event)


class FakeBacktestTradingHandler(TradingHandler):
    """
    simulates fills in a backtesting environment
    """

    def __init__(self, queue):
        super(FakeBacktestTradingHandler, self).__init__(queue)
        self.fakeid = 37
        self.lastprice = None

    def update_prices(self, datahandler):
        self.lastprice = datahandler.get_execution_data()

    def execute_order(self, event):
        if event.order_type == "MKT":
            if event.trigger is None:
                #MKT Order without Trigger
                price = self.lastprice['open']
                fill_event = FillEvent(event.symbol,
                                       'BATS', event.quantity, event.side, event.quantity * 0.01, self.fakeid, price,
                                       ordereventid=event.id)
                self.fakeid += 1
                self.queue.put(fill_event)
            else:
                #Trigger set
                if event.side == "BUY":
                    if event.trigger < self.lastprice['high']:
                        if event.trigger < self.lastprice['open']:
                            price = self.lastprice['open']
                        else:
                            price = event.trigger
                        fill_event = FillEvent(event.symbol,
                                               'BATS', event.quantity, event.side, event.quantity * 0.01, self.fakeid,
                                               price, ordereventid=event.id)
                        self.fakeid += 1
                        self.queue.put(fill_event)
                if event.side == "SELL":
                    if event.trigger > self.lastprice['low']:
                        if event.trigger > self.lastprice['open']:
                            price = self.lastprice['open']
                        else:
                            price = event.trigger
                        fill_event = FillEvent(event.symbol,
                                               'BATS', event.quantity, event.side, event.quantity * 0.01, self.fakeid,
                                               price, ordereventid=event.id)
                        self.fakeid += 1
                        self.queue.put(fill_event)

        elif event.order_type == "LMT":
            if event.side == "BUY":
                if event.limit > self.lastprice['low']:
                    if event.limit > self.lastprice['open']:
                        price = self.lastprice['open']
                    else:
                        price = event.limit
                    fill_event = FillEvent(event.symbol,
                                           'BATS', event.quantity, event.side, event.quantity * 0.01, self.fakeid,
                                           price, ordereventid=event.id)
                    self.fakeid += 1
                    self.queue.put(fill_event)
            elif event.side == "SELL":
                if event.limit < self.lastprice['high']:
                    if event.limit < self.lastprice['open']:
                        price = self.lastprice['open']
                    else:
                        price = event.limit
                    fill_event = FillEvent(event.symbol,
                                           'BATS', event.quantity, event.side, event.quantity * 0.01, self.fakeid,
                                           price, ordereventid=event.id)
                    self.fakeid += 1
                    self.queue.put(fill_event)


class IBTradingHandler(TradingHandler):
    """
    simulates fills in a backtesting environment
    """

    def __init__(self, queue, ibcon):
        super(IBTradingHandler, self).__init__(queue)
        self.ibcon = ibcon
        self.lastprice = None
        self.open_orders = Queue()
        self.get_fills()

    def update_prices(self):
        self.lastprice = self.ibcon.getspy()['last']

    def execute_order(self, event):
        side = event.side
        symbol = event.symbol
        size = event.quantity
        ordertype = event.order_type

        if ordertype == "LMT":
            lmtprice = event.limit
        else:
            lmtprice = 0
        if event.trigger is not None:
            stpprice = event.trigger
            ordertype = "STP" if ordertype == "MKT" else "STPLMT"
        else:
            stpprice = 0

        tif = "GTD"
        time_valid = dt.timedelta(minutes=event.time_valid) - dt.timedelta(seconds=1)
        goodtill = self.cet.localize(dt.datetime.today() + time_valid)

        self.open_orders.put({'orderid': self.ibcon.nextID, 'ordereventid': event.id, 'signalid': event.signalid})
        self.ibcon.place_order(side, symbol, size, ordertype, stpprice=stpprice, lmtprice=lmtprice, rth=1, tif=tif,
                               goodtill=goodtill, orderref=str(event.id))

    def get_fills(self):
        def check_orders():
            try: #TODO raus debug
                while True:
                    orderdict = self.open_orders.get()
                    order = orderdict['orderid']
                    if order in self.ibcon.orders:
                        if 'status' in self.ibcon.orders[order]:
                            if self.ibcon.orders[order]['status'] == "Filled":
                                ordercost = (self.ibcon.orders[order]['filled'] * 0.005) + \
                                            (round(self.ibcon.orders[order]['filled'] * self.ibcon.orders[order][
                                                'avgfillprice'] * 0.0000221, 2) *
                                             (self.ibcon.orders[order]['side'] == "SELL"))

                                fill_event = FillEvent(self.ibcon.orders[order]['symbol'], 'SMART',
                                                       self.ibcon.orders[order]['filled'],
                                                       self.ibcon.orders[order]['side'],
                                                       ordercost, order,
                                                       self.ibcon.orders[order]['avgfillprice'],
                                                       ordereventid=orderdict['ordereventid'],
                                                       permid=self.ibcon.orders[order]['permid'],
                                                       signalid=orderdict['signalid'])
                                self.queue.put(fill_event)
                                continue
                    self.open_orders.put(orderdict)
                    time.sleep(0.1)
            except:
                import sys

                msg = ", ".join([str(x) for x in sys.exc_info()])
                print msg
                self.queue.put(ErrorEvent(msg=msg))
                self.queue.put(StartStopEvent())
                raise

        t = threading.Thread(target=check_orders, name="check_orders")
        t.daemon = True
        t.start()

